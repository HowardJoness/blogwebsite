{"posts":[{"title":"ChatGPT Prompt 编辑器","content":"ChatGPT Prompt 编辑器 前言 一个使用 Streamlit 写的 Prompt 编辑器 主要功能 支持通过 ChatGPT 快速测试 Prompt 支持计算 Prompt 所耗费的token与资金 支持选择 ChatGPT 模型 支持设置 ChatGPT 代理 支持热更改 API KEY 支持热更改 ChatGPT API Prompt 测试环境支持流式传输 支持切换语言 快速开始 在运行前请先至 app.py 中修改 API KEY pip install -r requirements.txt streamlit run app.py 访问项目 一般来讲，使用 http://localhost:8501/ 即可访问项目 项目预览 运行环境 Python 3.8+ Streamlit 1.28.2 声明 本项目遵循 Apache-2.0 license 开源协议，使用前请悉知。 如果你想商用或程序定制，请先与我们联系，分享你的利益。 反馈交流 如果你遇到BUG欢迎反馈 使用 Issues 反馈 BUG 通过邮箱向我反馈问题 更多 无 ","link":"https://blog.howardjones.cn/post/ChatGPTPromptEditor-Chinese.md/"},{"title":"关于 YVD-2024-0121 漏洞的具体细节","content":" Tips:此漏洞已于几天前被修复 1.前情提要 差不多1月上旬一场期末复习语文模拟考的时候 我想到了这个问题 学校有刷脸的机器，而且也有推送端 点开推送链接会出现类似于如下的界面 于是我就在想 如果抓取数据包并稍作修改 能不能获得别人的数据？ 2.实操 说干就干 我史用小蓝鸟(原名Httpcanary 本文中附的链接是Github上已更名的“Reqable”项目)对推送回来的链接进行抓包 成功抓到数据包 抓到后尝试能否通过简单修改url以及请求头获得别人的数据 成功获取别人的数据 （无留档图片） 将请求头数据打包发到电脑上，使用python尝试重发请求 成功重发请求 稍加代码，即可批量爬取图片 成功复现bug 3.我的评价 我的评价：史 虽然学校以及未知的 软件公司已修复此漏洞 但我还是想说 我理解尼想要转型成数字化管理 但尼能布能在数字化管理的同时考虑一下学生的隐私怎么保护，这玩意才是最重要的 ","link":"https://blog.howardjones.cn/post/yvd-2024-0121/"},{"title":"突发奇想的数学问题","content":"（来自一节无聊的语文课……） 我们平时求一个长方形的面积会用 S=ab(长乘宽) 这个公式对吧？ 如果要把这个平面图形转换为立体图形，我们会给他一个厚度，公式变为 S=abh(长乘宽乘高) 更形象地解释： 这是一个平面 乘上高度后就有了厚度 但问题就出在高度上 在平面图形中，长和宽都有数据，高度为0 我们在 S=ab 的基础上乘 h(高) 就是为了让这个平面有高度 但，0乘任何数都得0 所以当 ab(长乘宽) 乘 h(高) 时，数据应该为0 但事实是 ab(长乘宽) 乘 h(高) 得数不是0 那么 h(高) 可能原本就有数据 因为他乘 h(高) 不得0 但如果 h(高) 原来有数据，那就意味着 S=ab(长乘宽) 其实有个隐形的 h(高) 只是我们看不到而已 既然 S=ab(长乘宽) 已经包含了原始高度数据，就说明 S=ab(长乘宽) 其实是个体积计算公式 但事实是他是面积公式 WHY? ","link":"https://blog.howardjones.cn/post/mathquestion1/"},{"title":"如何使用Python写Hello World","content":"（免责声明：若您在正式项目中真的使用了此方法来输出日志，说明您是傻逼） 使用Python写Hello world程序是一件非常繁琐且困难的事。 他涉及到网络、系统、字符串、进制转换等相关领域的知识。 今天，我们将编写一点简单的代码来实现输出Hello World。 1.准备工作 要输出Hello World，首先咱需要告诉计算机咱要输出什么。 新建一个文本文件“text.txt”用来存放咱的输出数据。 在 text.txt 中写入咱需要输出的数据，然后保存并关闭。 新建 main.py ，开始编程。 2.初试身手 进入VSCode，咱先要来读取text.txt中的内容。 使用open功能来读取： f = open(&quot;text.txt&quot;, &quot;r&quot;) t = f.read() f.close 运行程序，我们可以发现什么都没有，但其实程序以及读取了text.txt中的内容并储存到了t变量中。 接下来，我们要将字符串转化为电脑读得懂的语言——十六进制 使用“bitstring”库来将字符串转为十六进制 安装“bitstring”库： pip install bitstring 若尼没有可爱的CFW，建议尼使用清华pypi镜像站 安装完毕后，在尼程序的头上加一行代码： from bitstring import BitArray 用于导入这个库。 然后，使用 tb = BitArray(bytes=t.encode('utf-8')) 将t字符串转换为十六进制 再将十六进制数据存储到tb上。 为了方便我们查看程序的各项信息，咱使用open写一个函数，用于向日志文件（log.log）写入调试信息。 def log(text): f = open(&quot;log.log&quot;, &quot;w&quot;) f.write(text) f.close() 使用log(str(type(tb)))来查看tb变量的类型 可以发现是bitstring.bitarray.BitArray类型的 把type去掉，可以得到Hello World的十六进制数据 3.渐入佳境 获得16进制字符串后，我们要生成系统读得懂的命令 通过奶牛快传（口令：adq7jq）来下载服务端文件 在本地或服务器上运行std.bat，敲击两下空格使ip和端口默认（0.0.0.0:2224） 运行成功后，使用curl请求一下试试看 若返回ERROR 说明搭建成功 在main.py中，使用requests来获得能被计算机识别的命令 r = requests.post(f&quot;http://127.0.0.1:2224/?yl={tb}&quot;) r = r.text 最后，使用os.system执行这条命令 os.system(r) 运行！ 可以看到，运行成功了 4.后期维护 为了让调用更加方便，咱要将这几行代码封装成函数 def p(file='text.txt'): from bitstring import BitArray import requests import os f = open(&quot;text.txt&quot;, &quot;r&quot;) t = f.read() f.close() tb = str((BitArray(bytes=t.encode('utf-8')))) r = requests.get(f&quot;http://127.0.0.1:2224/?yl={tb}&quot;) r = r.text os.system(r) if __name__ == '__main__': p() 然后就可以在任意文件里调用此命令力！ ","link":"https://blog.howardjones.cn/post/HELLOWORLD/"},{"title":"做一个Github Page更新通知机器人","content":"刚刚把博客的关于更新了一下，但是屑Github总是要等几十秒钟才能更新完成。 但我，天生急性子，又不想来回刷新博客和github。因此，咱来做一个机器人。 首先，来理一下思路。 咱需要github的更新时间（实时的）以及一个能够让我注意到的提示渠道。 首先，挑一个提示渠道： 邮箱 (不常用) 哔哩哔哩 (゜-゜)つロ 干杯~-bilibili (消息提示不明显) QQ (煞笔腾讯已经封了我10多个小号了) 微信 (还好) X (我有病？) Steam (我有病？) Github (《鲁迅让周树人提醒他做事》) 看起来还是微信比较好一点。 代码上的思路就是： 程序获取代码仓库更新状态 如果更新了，发消息给微信 不然就等着 思路有了，实践开始。 Visual Studio Code，启动！ 询问了鸡批替后 咱获得了一个新的库：PyGithub 史用 pip install pyGithub 莱安装这个库 首先，咱来简单写一段测试： 当仓库的Deployment出现一个一分钟前的更新时，循环输出“GET”： from github import Github import datetime # GitHub 令牌、用户信息和仓库设置 token = &quot;cnm_b11444444fkunwolinpaiw1oai1mei4you5aaaa&quot; # 贵人的令牌 repo_name = &quot;???????????/bwobuzhidaoe&quot; # 贵人的仓库名（用户名/仓库名） # 使用 GitHub 令牌创建一个 Github 实例 g = Github(token) # 获取指定的仓库 repo = g.get_repo(repo_name) while True: # 获取仓库的最新 Deployment deployments = repo.get_deployments() if deployments.totalCount &gt; 0: latest_deployment = deployments[0] # 检查最新 Deployment 的时间 now = datetime.datetime.utcnow() deployment_time = latest_deployment.created_at if (now - deployment_time).total_seconds() &lt; 60: print('GET') else: print(&quot;草尼这妹部署过啊&quot;) break 运行！ 但是……报错了…… Traceback (most recent call last): File &quot;d:\\CODE\\main.py&quot;, line 25, in &lt;module&gt; if (now - deployment_time).total_seconds() &lt; 60: ~~~~^~~~~~~~~~~~~~~~~ TypeError: can't subtract offset-naive and offset-aware datetimes WEEEEEEE什么呢 简单查了一下，是因为GitHub API它返回的时间数据带时区信息 妹由事 咱有pytz from github import Github import datetime import pytz # 报错の拯救者 # GitHub 令牌、用户信息和仓库设置 token = &quot;cnm_y11444444114nmebiekanwolinpaiw1oai1mei4you5aaaa&quot; # 贵人的令牌 repo_name = &quot;???????????/bwobuzhidaoe&quot; # 贵人的仓库名（用户名/仓库名） # 使用 GitHub 令牌创建一个 Github 实例 g = Github(token) # 获取指定的仓库 repo = g.get_repo(repo_name) while True: # 获取仓库的最新 Deployment deployments = repo.get_deployments() if deployments.totalCount &gt; 0: latest_deployment = deployments[0] # 检查最新 Deployment 的时间 now = datetime.datetime.utcnow().replace(tzinfo=pytz.utc) # 设置咱的时间带有时区数据 deployment_time = latest_deployment.created_at if (now - deployment_time).total_seconds() &lt; 60: print('GET') else: print(&quot;草尼这妹部署过啊&quot;) break 再次运行 成功力 （若报错内容类似如下信息： Traceback (most recent call last): File &quot;d:\\CODE\\main.py&quot;, line 14, in &lt;module&gt; repo = g.get_repo(repo_name) ^^^^^^^^^^^^^^^^^^^^^ File &quot;C:\\Users\\HowardJonessssssssss\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\github\\MainClass.py&quot;, line 380, in get_repo headers, data = self.__requester.requestJsonAndCheck(&quot;GET&quot;, url) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File &quot;C:\\Users\\HowardJonessssssssss\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\github\\Requester.py&quot;, line 494, in requestJsonAndCheck return self.__check(*self.requestJson(verb, url, parameters, headers, input, self.__customConnection(url))) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File &quot;C:\\Users\\HowardJonessssssssss\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\github\\Requester.py&quot;, line 525, in __check raise self.createException(status, responseHeaders, data) github.GithubException.BadCredentialsException: 401 {&quot;message&quot;: &quot;Bad credentials&quot;, &quot;documentation_url&quot;: &quot;https://docs.github.com/rest&quot;} 说明尼妹由修改尼的token和repo_name） 但是，现在只是部署完毕的消息，并不是部署上线的消息 怎办？ 在GitHub API中，Deployment 对象包含了状态信息，咱能通过判断他的状态获取出成功与否 from github import Github import datetime import pytz # GitHub 令牌、用户信息和仓库设置 token = &quot;cnm_y11444444114nmebiekanwolinpaiw1oai1mei4you5aaaa&quot; # 贵人的令牌 repo_name = &quot;???????????/bwobuzhidaoe&quot; # 贵人的仓库名（用户名/仓库名） # 使用 GitHub 令牌创建一个 Github 实例 g = Github(token) # 获取指定的仓库 repo = g.get_repo(repo_name) while True: # 获取仓库的最新 Deployment deployments = repo.get_deployments() if deployments.totalCount &gt; 0: latest_deployment = deployments[0] # 获取与最新 Deployment 相关联的状态 statuses = latest_deployment.get_statuses() if statuses.totalCount &gt; 0: latest_status = statuses[0] if latest_status.state == &quot;success&quot;: # 检查最新 Deployment 的时间 now = datetime.datetime.utcnow().replace(tzinfo=pytz.utc) deployment_time = latest_deployment.created_at if (now - deployment_time).total_seconds() &lt; 60: print('VOCALLLLLLLLLLL 部署成功！！！！！') time.sleep(1) # 稍等一秒以避免过快打印 else: print(&quot;一分钟内没有部署&quot;) else: print(&quot;上一次最近的部署还妹豪&quot;) else: print(&quot;最新状态未知&quot;) else: print(&quot;草尼这妹部署过啊&quot;) break 将这段代码投入使用，可以发现运行正常 现在，咱内核有了，要开始写推送机制了 这里使用cluic大佬写的wxauto库制作wx机器人 这一步非常简单 只写个框架就行了 # wxbot.py from wxauto import * # 获取当前微信客户端 wx = WeChat() def sendmsgs(t): wx.SendMsg(t, '你大号（或是接收消息的人/群）') 回到main.py，加入调用框架的代码，程序就写完力： # main.py from github import Github import datetime import pytz import wxbot # GitHub 令牌、用户信息和仓库设置 token = &quot;cnm_y11444444114nmebiekanwolinpaiw1oai1mei4you5aaaa&quot; # 贵人的令牌 repo_name = &quot;???????????/bwobuzhidaoe&quot; # 贵人的仓库名（用户名/仓库名） # 使用 GitHub 令牌创建一个 Github 实例 g = Github(token) # 获取指定的仓库 repo = g.get_repo(repo_name) deployment_success = False Deploy_in_deployment = False while True: # 获取仓库的最新 Deployment deployments = repo.get_deployments() if deployments.totalCount &gt; 0: latest_deployment = deployments[0] # 获取与最新 Deployment 相关联的状态 statuses = latest_deployment.get_statuses() if statuses.totalCount &gt; 0: latest_status = statuses[0] if latest_status.state == &quot;success&quot;: # 检查最新 Deployment 的时间 now = datetime.datetime.utcnow().replace(tzinfo=pytz.utc) deployment_time = latest_deployment.created_at if (now - deployment_time).total_seconds() &lt; 60: if deployment_success == False: deployment_success = True wxbot.sendmsgs(&quot;网站部署成功！&quot;) else: print(&quot;一分钟内没有部署&quot;) deployment_success = False Deploy_in_deployment = False else: print(&quot;上一次最近的部署还妹豪&quot;) if Deploy_in_deployment == False: Deploy_in_deployment = True wxbot.sendmsgs(&quot;正在部署最新更新的网站……&quot;) else: print(&quot;最新状态未知&quot;) else: print(&quot;草尼这妹部署过啊&quot;) break # wxbot.py from wxauto import * # 获取当前微信客户端 wx = WeChat() def sendmsgs(t): wx.SendMsg(t,'不告诉你') 效果图： 这下 妈妈再也不用担心我错过网站更新力！ 注： [1]: wxauto需使用的微信版本为3.9.8.X，版本安装包可在wxauto的github仓库中下载 #!python3 # -*- coding: utf-8 -*- &quot;&quot;&quot; Author: tikic@qq.com Source: https://github.com/cluic/wxauto License: MIT License Version: 3.3.5.3 &quot;&quot;&quot; import uiautomation as uia import win32gui, win32con import win32clipboard as wc import time import os AUTHOR_EMAIL = 'tikic@qq.com' UPDATE = '2021-09-06' VERSION = '3.3.5.3' COPYDICT = {} class WxParam: SYS_TEXT_HEIGHT = 33 TIME_TEXT_HEIGHT = 34 RECALL_TEXT_HEIGHT = 45 CHAT_TEXT_HEIGHT = 52 CHAT_IMG_HEIGHT = 117 SpecialTypes = ['[文件]', '[图片]', '[视频]', '[音乐]', '[链接]'] class WxUtils: def SplitMessage(MsgItem): uia.SetGlobalSearchTimeout(0) MsgItemName = MsgItem.Name if MsgItem.BoundingRectangle.height() == WxParam.SYS_TEXT_HEIGHT: Msg = ('SYS', MsgItemName, ''.join([str(i) for i in MsgItem.GetRuntimeId()])) elif MsgItem.BoundingRectangle.height() == WxParam.TIME_TEXT_HEIGHT: Msg = ('Time', MsgItemName, ''.join([str(i) for i in MsgItem.GetRuntimeId()])) elif MsgItem.BoundingRectangle.height() == WxParam.RECALL_TEXT_HEIGHT: if '撤回' in MsgItemName: Msg = ('Recall', MsgItemName, ''.join([str(i) for i in MsgItem.GetRuntimeId()])) else: Msg = ('SYS', MsgItemName, ''.join([str(i) for i in MsgItem.GetRuntimeId()])) else: Index = 1 User = MsgItem.ButtonControl(foundIndex=Index) try: while True: if User.Name == '': Index += 1 User = MsgItem.ButtonControl(foundIndex=Index) else: break Msg = (User.Name, MsgItemName, ''.join([str(i) for i in MsgItem.GetRuntimeId()])) except: Msg = ('SYS', MsgItemName, ''.join([str(i) for i in MsgItem.GetRuntimeId()])) uia.SetGlobalSearchTimeout(10.0) return Msg def SetClipboard(data, dtype='text'): '''复制文本信息或图片到剪贴板 data : 要复制的内容，str 或 Image 图像''' if dtype.upper() == 'TEXT': type_data = win32con.CF_UNICODETEXT elif dtype.upper() == 'IMAGE': from io import BytesIO type_data = win32con.CF_DIB output = BytesIO() data.save(output, 'BMP') data = output.getvalue()[14:] else: raise ValueError('param (dtype) only &quot;text&quot; or &quot;image&quot; supported') wc.OpenClipboard() wc.EmptyClipboard() wc.SetClipboardData(type_data, data) wc.CloseClipboard() def Screenshot(hwnd, to_clipboard=True): '''为句柄为hwnd的窗口程序截图 hwnd : 句柄 to_clipboard : 是否复制到剪贴板 ''' import pyscreenshot as shot bbox = win32gui.GetWindowRect(hwnd) win32gui.SetWindowPos(hwnd, win32con.HWND_TOPMOST, 0, 0, 0, 0,\\ win32con.SWP_SHOWWINDOW|win32con.SWP_NOMOVE|win32con.SWP_NOSIZE) win32gui.SetWindowPos(hwnd, win32con.HWND_NOTOPMOST, 0, 0, 0, 0,\\ win32con.SWP_SHOWWINDOW|win32con.SWP_NOMOVE|win32con.SWP_NOSIZE) win32gui.BringWindowToTop(hwnd) im = shot.grab(bbox) if to_clipboard: WxUtils.SetClipboard(im, 'image') return im def SavePic(savepath=None, filename=None): Pic = uia.WindowControl(ClassName='ImagePreviewWnd', Name='图片查看') Pic.SendKeys('{Ctrl}s') SaveAs = Pic.WindowControl(ClassName='#32770', Name='另存为...') SaveAsEdit = SaveAs.EditControl(ClassName='Edit', Name='文件名:') SaveButton = Pic.ButtonControl(ClassName='Button', Name='保存(S)') PicName, Ex = os.path.splitext(SaveAsEdit.GetValuePattern().Value) if not savepath: savepath = os.getcwd() if not filename: filename = PicName FilePath = os.path.realpath(os.path.join(savepath, filename + Ex)) SaveAsEdit.SendKeys(FilePath) SaveButton.Click() Pic.SendKeys('{Esc}') def ControlSize(control): locate = control.BoundingRectangle size = (locate.width(), locate.height()) return size def ClipboardFormats(unit=0, *units): units = list(units) wc.OpenClipboard() u = wc.EnumClipboardFormats(unit) wc.CloseClipboard() units.append(u) if u: units = WxUtils.ClipboardFormats(u, *units) return units def CopyDict(): Dict = {} for i in WxUtils.ClipboardFormats(): if i == 0: continue wc.OpenClipboard() try: content = wc.GetClipboardData(i) wc.CloseClipboard() except: wc.CloseClipboard() raise ValueError if len(str(i))&gt;=4: Dict[str(i)] = content return Dict class WeChat: def __init__(self): self.UiaAPI = uia.WindowControl(ClassName='WeChatMainWndForPC') self.SessionList = self.UiaAPI.ListControl(Name='会话') # self.EditMsg = self.UiaAPI.EditControl(Name='输入') self.SearchBox = self.UiaAPI.EditControl(Name='搜索') self.MsgList = self.UiaAPI.ListControl(Name='消息') self.SessionItemList = [] def GetSessionList(self, reset=False): '''获取当前会话列表，更新会话列表''' self.SessionItem = self.SessionList.ListItemControl() SessionList = [] if reset: self.SessionItemList = [] for i in range(100): try: name = self.SessionItem.Name except: break if name not in self.SessionItemList: self.SessionItemList.append(name) if name not in SessionList: SessionList.append(name) self.SessionItem = self.SessionItem.GetNextSiblingControl() return SessionList def Search(self, keyword): ''' 查找微信好友或关键词 keywords: 要查找的关键词，str * 最好完整匹配，不完全匹配只会选取搜索框第一个 ''' self.UiaAPI.SetFocus() # time.sleep(0.2) self.UiaAPI.SendKeys('{Ctrl}f', waitTime=1) self.SearchBox.SendKeys(keyword, waitTime=1.5) self.SearchBox.SendKeys('{Enter}') def ChatWith(self, who, RollTimes=None): ''' 打开某个聊天框 who : 要打开的聊天框好友名，str; * 最好完整匹配，不完全匹配只会选取搜索框第一个 RollTimes : 默认向下滚动多少次，再进行搜索 ''' self.UiaAPI.SwitchToThisWindow() RollTimes = 10 if not RollTimes else RollTimes def roll_to(who=who, RollTimes=RollTimes): for i in range(RollTimes): if who not in self.GetSessionList()[:-1]: self.SessionList.WheelDown(wheelTimes=3, waitTime=0.1*i) else: # time.sleep(0.5) self.SessionList.ListItemControl(Name=who).Click(simulateMove=False) return 1 return 0 rollresult = roll_to() if rollresult: return 1 else: self.Search(who) return roll_to(RollTimes=1) def SendMsg(self, msg, window_title, clear=True): '''向当前窗口发送消息 msg : 要发送的消息 clear : 是否清除当前已编辑内容 ''' self.UiaAPI.SwitchToThisWindow() EditMsg = self.UiaAPI.EditControl(Name=f'{window_title}') if clear: EditMsg.SendKeys('{Ctrl}a', waitTime=0) EditMsg.SendKeys(msg, waitTime=0) EditMsg.SendKeys('{Enter}', waitTime=0) def SendFiles(self, *filepath, window_title, not_exists='ignore'): &quot;&quot;&quot;向当前聊天窗口发送文件 not_exists: 如果未找到指定文件，继续或终止程序 *filepath: 要复制文件的绝对路径&quot;&quot;&quot; global COPYDICT key = '' for file in filepath: file = os.path.realpath(file) if not os.path.exists(file): if not_exists.upper() == 'IGNORE': print('File not exists:', file) continue elif not_exists.upper() == 'RAISE': raise FileExistsError('File Not Exists: %s'%file) else: raise ValueError('param not_exists only &quot;ignore&quot; or &quot;raise&quot; supported') key += '&lt;EditElement type=&quot;3&quot; filepath=&quot;%s&quot; shortcut=&quot;&quot; /&gt;'%file if not key: return 0 if not COPYDICT: EditMsg = self.UiaAPI.EditControl(Name=f'{window_title}') EditMsg.SendKeys(' ', waitTime=0) EditMsg.SendKeys('{Ctrl}a', waitTime=0) EditMsg.SendKeys('{Ctrl}c', waitTime=0) EditMsg.SendKeys('{Delete}', waitTime=0) while True: try: COPYDICT = WxUtils.CopyDict() break except: pass wc.OpenClipboard() wc.EmptyClipboard() wc.SetClipboardData(13, '') wc.SetClipboardData(16, b'\\x04\\x08\\x00\\x00') wc.SetClipboardData(1, b'') wc.SetClipboardData(7, b'') for i in COPYDICT: copydata = COPYDICT[i].replace(b'&lt;EditElement type=&quot;0&quot;&gt;&lt;![CDATA[ ]]&gt;', key.encode()).replace(b'type=&quot;0&quot;', b'type=&quot;3&quot;') wc.SetClipboardData(int(i), copydata) wc.CloseClipboard() self.SendClipboard() return 1 def SendClipboard(self,window_title): '''向当前聊天页面发送剪贴板复制的内容''' self.SendMsg('{Ctrl}v',window_title) @property def GetAllMessage(self): '''获取当前窗口中加载的所有聊天记录''' MsgDocker = [] MsgItems = self.MsgList.GetChildren() for MsgItem in MsgItems: MsgDocker.append(WxUtils.SplitMessage(MsgItem)) return MsgDocker @property def GetLastMessage(self): '''获取当前窗口中最后一条聊天记录''' uia.SetGlobalSearchTimeout(1.0) MsgItem = self.MsgList.GetChildren()[-1] Msg = WxUtils.SplitMessage(MsgItem) uia.SetGlobalSearchTimeout(10.0) return Msg def LoadMoreMessage(self, n=0.1): '''定位到当前聊天页面，并往上滚动鼠标滚轮，加载更多聊天记录到内存''' n = 0.1 if n&lt;0.1 else 1 if n&gt;1 else n self.MsgList.WheelUp(wheelTimes=int(500*n), waitTime=0.1) def SendScreenshot(self, name=None, classname=None): '''发送某个桌面程序的截图，如：微信、记事本... name : 要发送的桌面程序名字，如：微信 classname : 要发送的桌面程序类别名，一般配合 spy 小工具使用，以获取类名，如：微信的类名为 WeChatMainWndForPC''' if name and classname: return 0 else: hwnd = win32gui.FindWindow(classname, name) if hwnd: WxUtils.Screenshot(hwnd) self.SendClipboard() return 1 else: return 0 ","link":"https://blog.howardjones.cn/post/make_a_deployment_bot/"}]}